function define(exportedArgs){var exports=exportedArgs;function errorToString(){return this.name+": "+this.message}function DoesNotUnderstandError(state,event,args){if(Error.captureStackTrace)Error.captureStackTrace(this,this.constructor);this.state=state;this.message="State '"+state.name+"' does not understand the '"+event+"' event";this.event=event;this.args=args}DoesNotUnderstandError.prototype.__proto__=Error.prototype;DoesNotUnderstandError.prototype.toString=errorToString;DoesNotUnderstandError.prototype.name=DoesNotUnderstandError.prototype.constructor.name;exports.DoesNotUnderstandError=DoesNotUnderstandError;function TransitionError(message,sourceState,targetState,err){if(Error.captureStackTrace)Error.captureStackTrace(this,this.constructor);this.message="while moving from state '"+sourceState.getStateName()+"' to state '"+targetState.getStateName()+"': "+message;this.sourceState=sourceState;this.targetState=targetState;this.err=err}TransitionError.prototype.__proto__=Error.prototype;TransitionError.prototype.toString=errorToString;TransitionError.prototype.name=TransitionError.prototype.constructor.name;exports.TransitionError=TransitionError;function NestedTransitionError(sourceState,targetState){if(Error.captureStackTrace)Error.captureStackTrace(this,this.constructor);this.message="Transition was run to completion before another transition is requested; _enter/_exit must NOT request a transition";this.sourceState=sourceState;this.targetState=targetState}NestedTransitionError.prototype.__proto__=Error.prototype;NestedTransitionError.prototype.toString=errorToString;NestedTransitionError.prototype.name=NestedTransitionError.prototype.constructor.name;exports.NestedTransitionError=NestedTransitionError;function AssertionError(message){if(Error.captureStackTrace)Error.captureStackTrace(this,this.constructor);this.message=message}AssertionError.prototype.__proto__=Error.prototype;AssertionError.prototype.toString=errorToString;AssertionError.prototype.name=AssertionError.prototype.constructor.name;exports.AssertionError=AssertionError;function assert(contidition,message){if(!contidition)throw new AssertionError(message)}function StateInitializationError(message){if(Error.captureStackTrace)Error.captureStackTrace(this,this.constructor);this.message=message}StateInitializationError.prototype.__proto__=Error.prototype;StateInitializationError.prototype.toString=errorToString;StateInitializationError.prototype.name=StateInitializationError.prototype.constructor.name;exports.StateInitializationError=StateInitializationError;var debugMode=false;exports.dbgMode=function(isEnabled){if(isEnabled===undefined){return debugMode}assert(typeof isEnabled=="boolean");debugMode=isEnabled;return debugMode};exports.dbgInspectState=function(state){};exports.State=function State(stateName,parentState){this.name=stateName;this.initialState=null;this.subStates=[];this.error=this.error||function(e,err){throw err};this.doesNotUnderstandError=this.doesNotUnderstandError||function(o,e,evt,args){throw new DoesNotUnderstandError(o.__behaviour__.state.name,evt,args)};if(exports.dbgMode){if(this._enter!==undefined){var userDefinedEnter=this._enter;this._enter=function(){this.__behaviour__.trace("enter "+this.__behaviour__.state.name+"\n");userDefinedEnter.call(this)}}else{this._enter=function(){this.__behaviour__.trace("enter "+this.__behaviour__.state.name+"\n")}}}else{this._enter=this._enter||function(){}}if(exports.dbgMode){if(this._exit!==undefined){var userDefinedExit=this._exit;this._exit=function(){userDefinedExit.call(this);this.__behaviour__.trace("exit "+this.__behaviour__.state.name+"\n")}}else{this._exit=function(){this.__behaviour__.trace("exit "+this.__behaviour__.state.name+"\n")}}}else{this._exit=this._exit||function(){}}if(parentState!==undefined)this.__proto__=parentState};State=exports.State;exports.state=function(name,parentState,isFirstChild){if(parentState===undefined)parentState=State;if(isFirstChild===undefined)isFirstChild=null;var st=new State(name);return st};var Global=new State("Global");function enterState(obj,state){if(obj.__behaviour__.locked)throw new TransitionError("Fatal Error: Cannot execute a transition while entering a state",obj.__state__,state,new NestedTransitionError(obj.__state__,state));obj.__behaviour__.locked=true;try{obj.__behaviour__.state._enter.call(obj)}catch(err){throw new TransitionError("Fatal Error: An error was thrown by the '_enter' callback",obj.__state__,state,err)}obj.__behaviour__.locked=false}function exitState(obj,state){if(obj.__locked__)throw new TransitionError("Cannot execute a transition while exiting a state",obj.__state__,state,new NestedTransitionError(obj.__state__,state));obj.__behaviour__.locked=true;try{obj.__behaviour__.state._exit.call(obj)}catch(err){throw new TransitionError("An error was thrown by the '_exit' callback",this.__state__,state,err)}finally{obj.__behaviour__.locked=false}}exports.init=function(obj,state,dispatcherName){if(typeof obj!=="object")throw new TypeError("obj argument must be an object");if(!(state instanceof State))throw new TypeError("obj argument must be an object");obj.__behaviour__=new Behaviour(state);enterState(obj,state);obj.__behaviour__.state=state};exports.currentState=function(obj){return obj.__behaviour__.state};exports.tran=function(obj,targetState){assert(targetState.constructor instanceof State);var sourceState=this.__behaviour__.state;exitState(obj,sourceState);obj.__behaviour__.__state__=targetState;enterState(obj,targetState)};return exports}define(typeof exports==="undefined"?this.qwe={}:exports);